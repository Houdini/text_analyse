=Анализатор текста

Программа может считать разные характеристики для коллекции текстов.

=Как это работает

Пусть есть коллекция документов в формате cp1251, для начала ее нужно обработать программой mystem и конвертировать в utf-8, для этого в скрипте mystem_for_directories нужно
указать где находится mystem, далее запустить ./mystem /path/to/collection
Скрипт заменит документы в этой папке уже обработанными в нужной кодировке.

Далее, для каждой коллекции нужно создать директорию куда будет помещаться результат вычислений. Обе эти директории нужно прописать в config.yml, так же и название коллекции

Все файлы хранятся в формате

    в 55630
    и 27990
    на 22674
    по 14919
    быть 11676
    с 11663
    что 8925
    год 7909

вначале идет слово или несколько слов, далее параметр.
Он автоматически конвертируется в хэш {:в => 55630, :и => 27990 и так далее}
Ключами являются переменная типа symbol

В директории с результатами уже должны быть указаны (для работы большинства других алгоритмов)
normal_words_amount, в ней сидят слова приведенные к нормальному виду и их количество (формат как в примере)
words_per_collection нормальное слово -- в скольких документах оно встречается

После инициализации

     c  = CollectionsSet.new 'config.yml'

Будет доступен хэш, с именем коллекции, значением ключа -- объект типа коллекция
в коллекции будут прописаны все файлы с данными, например в коллекции gtz_polit
есть следующие файлы

     normal_words_amount
     original_words_amount
     words_per_collection
     phrase_A_N
     phrase_V_S
     idf
     ridf

тогда будет такая структура данных

     c.set[:gtz_polit].data_files = {:idf => 'путь к idf', :ridf => 'путь к ridf', :phrase_A_N => 'путь к этому файлу' и так далее}
     c.set[:gtz_polit].docuemnts = ... количество документов в коллекции
     c.set[:gtz_polit].data = {} данных пока нету

после строчек

     c.set.each_value {|collection| collection.load_data }

для каждой коллекции выполнится метод загрузить данные, тогда data будет выглядеть

     c.set[:gtz_polit].data = {:idf => {:слово => 6.43, :другое_слово => 6.42 и так далее}, :ridf => {аналогичный хэш типа слово значение}, :phrase_A_N => {опять пара слов -- значение}}

обратиться к данным можно соответственно

    c.set[:gtz_polit].data[:idf] -- вернутся хэш

так можно пробежаться по хэшу

     c.set[:gtz_polit].data[:idf].each_key do |key|
        p "Ключ #{key} -- значение #{c.set[:gtz_polit].data[:idf][key]}"
     end

=Методы

Все методы вызываются со знаком ! и без
Разница в том, что метод ! пересчитывает все данные заново, и заново сохраняет результат
Метод без ! вернет true если данные уже есть и не будет ничего делать

сейчас есть следующие методы:

    idf -- для каждого слова вычисляет idf
    ridf -- для каждого слова вычисляет ridf
    phrase(принимает части речи), например phrase :V, :S найдет все словосочетания типа глагол-существительное и их количество, может принимать неограниченное количество переменных
    t_test :V, :S вернет для каждого такого словосочетания значение статистики стьюдента

вызывать методы для всех коллекций можно так

    c.each_collection do |collection|
        collection.phrase! :A, :N
    end

    c.each_collection do |collection|
        collection.rifd
    end

и так далее

=Методы чтения

в коллекции достпны два метода обработки строк

    each_line_documents -- проходит все строчки всех документов коллекции
    each_line_document -- проходит все строчки первого документа коллекции, удобен для тестов

каждый из них принимает блок, то есть их можно использовать следующим образом:

    res = {}
    each_line_documents do |line|
        сдесь делаем что нибудь со строчкой и сохраняем в res
    end

=Метод записи

save_hash_to_file hash, name
метод принимает хэш и имя файла

записывает его в директорию с данными с указанным файлом

=Построение графика

У коллекции есть метод plot который принимает имя того чего хотим построить
к примеру plot :idf, ключи пронумерует 1, 2, 3 ... и отложит их по оси абсцичч, значение по оси ординат
